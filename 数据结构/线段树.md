# 线段树

## 线段树解决了什么问题:

假设需要维护一个数组,针对于这个数组,需要多次查询具有区间结合性的运算结果(如:区间最值,加和,乘积,异或等),并且同时需要进行具有区间结合性的修改操作(如区间加,区间减,区间异或),当数组的长度达到10000+,查询和修改操作也达到10000+的量级时候,假定数组大小为n,操作次数为m,则朴素的时间复杂度为O(nm).考虑在最差情况下,例如查询和修改100000次[1,100000],那么循环遍历次数甚至达到了亿级,那么此时就不能使用朴素方法来实现.

而线段树可以在时间复杂度O(logn)内完成单次的查找和更新操作,那么总的时间复杂度就是O(mlogn)

## 线段树简介

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-34-29-image.png)

线段树是一种二叉搜索树,树种的每个节点都代表一个区间,叶子节点代表单位区间.并且每个节点都代表父节点区间的一半, 从而保证树的深度为logn.当修改的时候以懒惰标记记录当前节点的所有子节点都需要进行更新从而不需要将修改落实到子节点,如此保证修改时的时间复杂度也不会超过logn.

### 线段树支持的基本操作

INSERT(t,line):将包含在某一区间的元素line插入到树t中
DELETE(t,line):将包含在某一区间的元素line从树t中删除
SEARCH(t,line):返回某一区间的线段数量

### 线段树的函数功能

1. 线段树的初始化功能,将线段树中的所有节点设置为需要维护的数组相应区间的初值.
2. 修改分为单值修改和多值修改
3. 查询分为单点查询和区间查询

## 线段树实现与分析

### 线段树节点定义

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-35-58-image.png)

线段树的底层结构是一个二叉树,所以其节点和二叉树的节点相类似,包含值和左右儿子的引用,

操作类型枚举和操作数两个字段作为懒惰标记使用,在修改数据的时候使用.
因为线段树的每一个节点对应为一个区间,所有还应该记录其代表区间的左右边界.

### 线段树的初始化

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-36-36-image.png)

由于线段树也是一种二叉树,所以树的初始化方式和普通的二叉树相类似,只不过在构建节点的时候需要同时设置节点的边界以及节点中存储的值(这里以最小值为例)

### 线段树区间查找

情形一:查找区间为节点的子区间,并且经过区间中点

当查找区间包含在节点区间,并且经过中点的,以为区间不匹配,并且是包含的关系,此时节点中记录的 最小值就不能作为查找区间的最小值进行返回,此时就需要进行递归遍历其子树,又因为该区间经过中点,查找区间的值会被同时存储到左右儿子节点中,所以此时需要同时遍历左右子树,并且查找区间也要相应的按照中点进行拆分

情形二:查找区间为节点的子区间,但不经过中点

这种情况和情形一相类似,但是区别就是不经过中点,那么在进行遍历的时候只需要遍历一个子树就就可以作为当前查找区间的最小值.注意当前的查找区间不一定是程序要查询的最小区间,因为查询区间会在调用左右子树的时候进行分割

情形三:查询区间恰好为和节点区间向匹配

当查找区间恰好和节点区间相同的时候,那么使用当前节点存储的最小值直接返回就可以,不在需要进行递归查询.此种情况也查询操作的递归基.

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-37-09-image.png)

### 线段树的区间查找的性能分析

结论: 线段树的查找效率为 O(logn)

定理 : 当n>3时,一个[1,n]的线段树可以将[1,n]的任意子区间[L,R]分解为不超过2(Log2n)个子区间

复杂度推导 : 在上述定理成立的前提下,考虑最差情况.假定需要遍历到树的最深层才能匹配到查找区间.在查找过程中,每层的时间复杂度为2O(1),层数为log(n),总时间为f(t)=2*O(1)*logn = O(logn)

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-38-46-image.png)

定理推导 : 首先考虑最下层,将下层在区间内的所有在区间[L,R]的节点选中,在这些被选中的节点中,如果两个相邻的节点的父节点为同一个,那个这两个节点在进行查询的时候就不会被查询到,查询到他们的父节点就会终止,当最底层所有父节点相同的节点都被替换掉的时候,底层最多剩余两个节点.同理,次底层的节点也可以被他们的父节点所替代,那么针对于整颗树,进行如上替代之后,每层最多剩余两个节点,那么分割的总节点数量就是2(Log2n)

### 线段树区间查找实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-38-56-image.png)

### 线段树的单值插入

线段树的单值修改逻辑较为简单,只是需要针对于每个节点进行遍历,判断节点处于该节点的左子树或者右子树即可,当递归到叶子节点时直接进行修改即可.并且在修改之后需要对当前节点存储的计算结果进行更新

单值修改复杂度为O(logn)

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-39-28-image.png)

### 线段树单值修改实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-39-39-image.png)

### 线段树的区间修改

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-40-02-image.png)

#### 线段树节点更新

线段树的节点更新和线段树的区间查找想类似,核心思想都是通过递归找到区间完全处于更新区间的节点,并且对这些节点进行更新.
      需要注意的是,为了使得区间更新的效率能维持在O(logn),线段树在更新的时候提出了懒惰标记这个概念,从而避免了针对于区间的所有节点都进行更新,提高了时间效率.
      在进行更新的时候,如果能够判断当前节点的所有儿子节点都需要进行更新,那么就会给该节点打上懒惰标记,对其儿子节点的更新则会被暂时搁置,但是该节点中的信息进行更新.被懒惰标记标记的节点意义为:该节点中的信息已经被更新,该节点下的所有儿子节点需要进行同样的更新,但是还没有更新.
      在更新时候,如果遍历到了叶子节点,那么不会给叶子节点打上懒惰标记,而是会直接对节点进行更新.
      虽然节点在更新的时候会被打上懒惰标记,但是清除懒惰标记却并不是在更新的时候完成的,而是在线段树进行区间查询的时候,在查询的时候,如果持有懒惰标记的节点被命中,并且查询区间被包含在节点的区间中,那么按照查询的逻辑会对该节点的两个儿子节点进行递归遍历,但是其儿子节点却没有被更新,所以在迭查询之前有个懒惰标记下放的过程.

### 线段树的区间修改样例

#### 线段树节点更新

如左图所示,如果要更新区间[1-5],那么被完全命中的节点为叶子节点[1,1],两个非叶子节点[2,3],[4,5].因为节点[1,1]是叶子节点,所以会直接进行更新,而节点[2,3]和节点[3,4]会被打上节点懒惰标记.至此,区间更新函数退出.
          紧接着如果进行查询,假定查找区间为[3,4],那么查询到[2,3]节点的时候,此时的查找区间为[3,3],需要查询该节点的右子树,但是其右子树还没有进行上次更新,在遍历其右子树之前进行懒惰标记下放,又因为左右儿子节点是叶子节点,所以此次下放操作直接会对两个叶子节点进行更新.另一侧的情况类似,只有当整个线段树中所有的节点都不在持有懒惰标记的时候,一次更新才算完全作用到了线段树的每一个节点.

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-40-54-image.png)

### 线段树的区间更新实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-41-04-image.png)

### 线段树的懒惰标记下放实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-41-16-image.png)

## 可持久化线段树简介

### 数据历史版本问题:

例如线段树的应用场景,如果在场景中我们需要增加对于数据版本的维护,也就是在一次更新之后,需要同时保留更新前和更新后的数据.这种情况下可以创建一个线段树的副本,并且针对这个副本进行更新,虽然这样可以解决问题,但是稍加思索就会发现,如果更新仅仅是一个单值更新的化,那么这种存储方式势必会浪费许多空间.

### 可持久化线段树的原理

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-41-45-image.png)

#### 可持久化线段树核心原理

可持久化线段树和核心思想是在进行更新的时候,只新增必要的新节点,对于上下的可以复用的节点进行复用,并且在存储的时候就不能使用数组的方式来存储树结构,需要使用动态开辟的方式.在只操作单点更新的可持久化线段树中,是有第一棵树是存储了树的全部节点,而后续的每个版本值存储更新那个节点到新根节点的一条路径,所以就是每次增加一个版本,只需要开辟O(logn)的空间即可,相较于存储多个树备份的方法节省了很大的空间.

### 可持久化线段树单值带版本更新实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-42-18-image.png)

### 可持久化线段树区间更新实现

![](/Users/astoria/IdeaProjects/githubPro/noteBook/imageDir/2022-01-13-17-42-39-image.png)
